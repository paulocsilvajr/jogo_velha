package main

import (
	"fmt"
	"math"
	"math/rand"
)

const (
	Vazio        = 0
	O            = 1
	X            = 2
	LimiteLinha  = 3
	LimiteColuna = LimiteLinha
)

var I = map[int]string{0: " ", 1: "O", 2: "X"}

type ticTacToe struct {
	tabuleiro [LimiteLinha][LimiteColuna]int
}

type posicoesRelativas [LimiteLinha][2]int

func main() {
	// velha := makeTicTacToe(1)

	for i := 0; i < 5; i++ {
		velha := makeTeste(i)
		velha.imprime()

		s, pos := velha.getSimboloPosicaoMarcacoesEmSequencia()
		fmt.Printf("Marcaçoes em sequência: [%s] linha: %d, coluna: %d\n", getSimbolo(s), pos[0]+1, pos[1]+1)

		s, pos = velha.getSimboloPosicaoDuasMarcacoesEmSequencia()
		fmt.Printf("2 Marcaçoes em sequência: [%s] linha: %d, coluna: %d\n", getSimbolo(s), pos[0]+1, pos[1]+1)

		fmt.Println()
	}

	// os.Exit(0)
}

// FUNÇÕES RELACIONADAS A STRUCT ticTacToe

func (self *ticTacToe) zera() {
	for i := 0; i < LimiteLinha; i++ {
		for j := 0; j < LimiteColuna; j++ {
			self.tabuleiro[i][j] = Vazio
		}
	}
}

func (self *ticTacToe) exemplo() {
	self.tabuleiro = [3][3]int{
		[3]int{X, Vazio, Vazio},
		[3]int{X, Vazio, Vazio},
		[3]int{Vazio, Vazio, Vazio},
	}
}

func makeTeste(numero int) (jogoVelha ticTacToe) {
	jogoVelha = ticTacToe{}
	switch numero {
	case 0:
		jogoVelha.tabuleiro = [3][3]int{
			[3]int{Vazio, Vazio, Vazio},
			[3]int{Vazio, Vazio, Vazio},
			[3]int{X, Vazio, X},
		}
	case 1:
		jogoVelha.tabuleiro = [3][3]int{
			[3]int{Vazio, Vazio, Vazio},
			[3]int{Vazio, X, Vazio},
			[3]int{X, Vazio, Vazio},
		}
	case 2:
		jogoVelha.tabuleiro = [3][3]int{
			[3]int{Vazio, Vazio, O},
			[3]int{Vazio, O, Vazio},
			[3]int{Vazio, Vazio, Vazio},
		}
	case 3:
		jogoVelha.tabuleiro = [3][3]int{
			[3]int{X, Vazio, Vazio},
			[3]int{Vazio, X, Vazio},
			[3]int{Vazio, Vazio, Vazio},
		}
	case 4:
		jogoVelha.tabuleiro = [3][3]int{
			[3]int{Vazio, Vazio, Vazio},
			[3]int{Vazio, O, Vazio},
			[3]int{Vazio, Vazio, O},
		}
	}

	return

}

func makeTicTacToe(op int) ticTacToe {
	jogoVelha := ticTacToe{}
	if op == 1 {
		jogoVelha.exemplo()
	} else {
		jogoVelha.zera()
	}

	return jogoVelha
}

func (self *ticTacToe) imprime() {
	numHorizontais := "    1   2   3"
	linhaSeparadora := "  +---+---+---+"
	fmt.Println(numHorizontais)
	fmt.Println(linhaSeparadora)

	for numVerticais, linha := range self.tabuleiro {
		fmt.Printf("%d ", numVerticais+1)
		for _, coluna := range linha {
			fmt.Printf("| %s ", getSimbolo(coluna))
		}
		fmt.Println("|\n" + linhaSeparadora)
	}

}

func getSimbolo(valor int) string {
	switch valor {
	case O:
		return I[valor]
	case X:
		return I[valor]
	default:
		return I[0]
	}
}

func (self *ticTacToe) getLinha(posicao int) ([LimiteLinha]int, posicoesRelativas) {
	ehPosicaoValida(&posicao)

	var posicoes posicoesRelativas
	for i := 0; i < LimiteLinha; i++ {
		posicoes[i] = [2]int{posicao, i}
	}

	return self.tabuleiro[posicao], posicoes
}

func (self *ticTacToe) getColuna(posicao int) ([LimiteColuna]int, posicoesRelativas) {
	ehPosicaoValida(&posicao)
	var colunaTemp [LimiteColuna]int

	var posicoes posicoesRelativas
	for i := 0; i < LimiteLinha; i++ {
		posicoes[i] = [2]int{i, posicao}
	}

	for i, linha := range self.tabuleiro {
		for j, coluna := range linha {
			if j == posicao {
				colunaTemp[i] = coluna
			}
		}
	}

	return colunaTemp, posicoes
}

func (self *ticTacToe) getDiagonal(posicao int) ([LimiteLinha]int, posicoesRelativas) {
	var diagonalTemp [LimiteLinha]int

	var posicoes posicoesRelativas

	if posicao == 1 {
		// diagonal secundária
		posicao = LimiteColuna
		for i, linha := range self.tabuleiro {
			posicao--
			diagonalTemp[i] = linha[posicao]
		}

		col := LimiteLinha
		for i := 0; i <= 2; i++ {
			col--
			posicoes[i] = [2]int{i, col}
		}

	} else {
		// diagonal principal
		posicao = 0
		for i, linha := range self.tabuleiro {
			diagonalTemp[i] = linha[posicao]
			posicao++
		}

		for i := 0; i < LimiteLinha; i++ {
			posicoes[i] = [2]int{i, i}
		}
	}

	return diagonalTemp, posicoes
}

func ehPosicaoValida(posicao *int) {
	if *posicao >= LimiteLinha {
		*posicao = 0
	} else if *posicao < 0 {
		*posicao = 0
	}
}

func (self *ticTacToe) getSimboloPosicaoMarcacoesEmSequencia() (simbolo int, posicao [2]int) {
	/*
		Função que retorna o símbolo(int) e a posição[linha,coluna]([2]int)
		que falta para ser marcado para fazer 3 marcações em sequência.
		Se retornar Vazio(0), a posição retornada é a última vazia livre.
	*/
	quantSequencia := LimiteLinha - 1
	quantLacos := LimiteLinha*2 + 2
	for i := 0; i < quantLacos; i++ {
		x, o, v := 0, 0, 0 // quantidade de x, o, v(azio)

		var sequencia [LimiteLinha]int
		var posicoes [LimiteLinha][2]int

		p := i // p é a posição relativa para as funções de linha, coluna e diagonal
		if i < LimiteLinha {
			sequencia, posicoes = self.getLinha(p)
		} else if i < LimiteLinha*2 {
			p -= LimiteLinha
			sequencia, posicoes = self.getColuna(p)
		} else {
			p -= LimiteLinha * 2
			sequencia, posicoes = self.getDiagonal(p)
		}

		for j, item := range sequencia {
			switch item {
			case X:
				x++
			case O:
				o++
			default:
				v++

				posicao = posicoes[j]
			}

		}

		// se falta uma célula para marcar X
		if x == quantSequencia && v == 1 && o == 0 {
			simbolo = X
			return
			// se falta uma célula para marcar O
		} else if o == quantSequencia && v == 1 && x == 0 {
			simbolo = O
			return
		}
	}

	simbolo = Vazio
	return

}

func (self *ticTacToe) getSimboloPosicaoDuasMarcacoesEmSequencia() (simbolo int, posicao [2]int) {
	/*
		Função que retorna o símbolo(int) e a posição[linha,coluna]([2]int)
		que falta para formar duas marcações em sequência em dois eixos do tabuleiro.
		Se retornar Vazio(0), a posição retornada
	*/
	quantSequencia := LimiteLinha - 1
	quantLacos := 5

	for i := 0; i <= quantLacos; i++ {
		x, o, v := 0, 0, 0 // quantidade de x, o, v(vazio)

		var sequencia []int

		switch i {
		case 0:
			// L linha 0, coluna 0
			sequencia, posicao = self.getSequenciaPosicao(0, 0)
			// fmt.Println("L 0 0")
		case 1:
			// L linha 0, coluna 2
			sequencia, posicao = self.getSequenciaPosicao(0, 2)
			// fmt.Println("L 0 2")
		case 2:
			// L linha 2, coluna 2
			sequencia, posicao = self.getSequenciaPosicao(2, 2)
			// fmt.Println("L 2 2")
		case 3:
			// L linha 2, coluna 0
			sequencia, posicao = self.getSequenciaPosicao(2, 0)
			// fmt.Println("L 2 0")
		case 4:
			// + central
			sequencia, posicao = self.getSequenciaPosicao(1, 1)
			// fmt.Println("+ central")
		case 5:
			// x diagonal
			sequencia, posicao = self.getSequenciaPosicao(-1, -1)
			// fmt.Println("x diagonal")
		}

		for j := 0; j < len(sequencia); j++ {
			item := sequencia[j]
			switch item {
			case X:
				x++
			case O:
				o++
			default:
				v++
			}
		}

		if x == quantSequencia && v == 3 && o == 0 {
			simbolo = X
			fmt.Println(">>>", i)
			return
		} else if o == quantSequencia && v == 3 && x == 0 {
			simbolo = O
			fmt.Println(">>>", i)
			return
		}

		//		if x == quantSequencia && v == 3 && o == 0 && sequencia[0] == Vazio {
		//			simbolo = X
		//			return
		//		} else if o == quantSequencia && v == 3 && x == 0 && sequencia[0] == Vazio {
		//			simbolo = O
		//			return
		//		} else if x == quantSequencia && v == 3 && o == 0 && sequencia[1] == Vazio {
		//			simbolo = X
		//			return
		//		} else if o == quantSequencia && v == 3 && x == 0 && sequencia[1] == Vazio {
		//			simbolo = O
		//			return
		//		}

	}

	simbolo = Vazio
	return
}

func (self *ticTacToe) getSequenciaPosicao(linha int, coluna int) (sequencia []int, posicao [2]int) {
	var posicoes [][2]int

	if linha == -1 && coluna == -1 {
		s, p := self.getDiagonal(0)
		for k := 0; k < len(s); k++ {
			sequencia = append(sequencia, s[k])
			posicoes = append(posicoes, p[k])
		}

		// retira o elemento duplicado no cruzamento do tipo x
		s, p = self.getDiagonal(1)
		for k := 0; k < len(s); k++ {
			if k != 1 {
				sequencia = append(sequencia, s[k])
				posicoes = append(posicoes, p[k])
			}
		}

		fmt.Println(sequencia, posicoes) // APAGAR

		// se o centro está vazio
		if sequencia[1] == Vazio {
			posicao = posicoes[1]
		} else {
			if sequencia[0] == Vazio && sequencia[2] == Vazio {
				opcoes := []int{0, 2}
				posicao = posicoes[opcoes[rand.Intn(len(opcoes))]]
			} else if sequencia[3] == Vazio {
				posicao = posicoes[3]
			} else if sequencia[4] == Vazio {
				posicao = posicoes[4]
			}
		}
	} else {

		s, p := self.getLinha(linha)
		for k := 0; k < len(s); k++ {
			sequencia = append(sequencia, s[k])
			posicoes = append(posicoes, p[k])
		}

		// retira o elemento duplicado no cruzamento do tipo...
		// ... +
		if linha == 1 && coluna == 1 {
			s, p = self.getColuna(coluna)
			for k := 0; k < len(s); k++ {
				if k != coluna {
					sequencia = append(sequencia, s[k])
					posicoes = append(posicoes, p[k])
				}
			}

			// .. T
			//		} else if (linha - coluna) == 1 {
			//			s, p = self.getColuna(coluna)
			//			for k := 0; k < len(s); k++ {
			//				if k == 1 {
			//					sequencia = append(sequencia, s[k])
			//					posicoes = append(posicoes, p[k])
			//				}
			//			}

			// ... L
		} else if math.Abs(float64(linha-coluna)) == 2.0 {
			s, p = self.getColuna(coluna)
			for k := 1; k < len(s); k++ {
				sequencia = append(sequencia, s[k])
				posicoes = append(posicoes, p[k])
			}
		}

		posicao = posicoes[coluna]
	}

	return
}

// FUNÇÕES RELACIONADAS A STRUCT tictacToe
